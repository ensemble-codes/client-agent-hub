{"version":3,"sources":["../src/index.ts","../src/base.ts","../src/environment.ts","../src/interactions.ts","../src/utils.ts","../src/post.ts"],"sourcesContent":["import { Client, elizaLogger, IAgentRuntime } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base.ts\";\nimport { validateTwitterConfig } from \"./environment.ts\";\nimport { TwitterInteractionClient } from \"./interactions.ts\";\nimport { TwitterPostClient } from \"./post.ts\";\n\nclass AgentHubManager {\n    client: ClientBase;\n    post: TwitterPostClient;\n    interaction: TwitterInteractionClient;\n    constructor(runtime: IAgentRuntime, enableSearch: boolean) {\n        this.client = new ClientBase(runtime);\n        this.post = new TwitterPostClient(this.client, runtime);\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\n    }\n}\n\nexport const AgentHubClientInterface: Client = {\n    async start(runtime: IAgentRuntime) {\n        await validateTwitterConfig(runtime);\n\n        elizaLogger.log(\"Twitter client started\");\n\n        const manager = new AgentHubManager(runtime, this.enableSearch);\n\n        await manager.client.init();\n\n        await manager.post.start();\n\n        await manager.interaction.start();\n\n        return manager;\n    },\n    async stop(_runtime: IAgentRuntime) {\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\n    },\n};\n\nexport default AgentHubManager;\n","import {\n    Content,\n    IAgentRuntime,\n    IImageDescriptionService,\n    Memory,\n    State,\n    UUID,\n    getEmbeddingZeroVector,\n    elizaLogger,\n    stringToUuid,\n} from \"@ai16z/eliza\";\nimport {\n    QueryTweetsResponse,\n    Scraper,\n    SearchMode,\n    Tweet,\n} from \"agent-twitter-client\";\nimport { EventEmitter } from \"events\";\n\nexport function extractAnswer(text: string): string {\n    const startIndex = text.indexOf(\"Answer: \") + 8;\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\n    return text.slice(startIndex, endIndex);\n}\n\ntype TwitterProfile = {\n    id: string;\n    username: string;\n    screenName: string;\n    bio: string;\n    nicknames: string[];\n};\n\nclass RequestQueue {\n    private queue: (() => Promise<any>)[] = [];\n    private processing: boolean = false;\n\n    async add<T>(request: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await request();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.processQueue();\n        });\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const request = this.queue.shift()!;\n            try {\n                await request();\n            } catch (error) {\n                console.error(\"Error processing request:\", error);\n                this.queue.unshift(request);\n                await this.exponentialBackoff(this.queue.length);\n            }\n            await this.randomDelay();\n        }\n\n        this.processing = false;\n    }\n\n    private async exponentialBackoff(retryCount: number): Promise<void> {\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n\n    private async randomDelay(): Promise<void> {\n        const delay = Math.floor(Math.random() * 2000) + 1500;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n}\n\nexport class ClientBase extends EventEmitter {\n    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\n    twitterClient: Scraper;\n    runtime: IAgentRuntime;\n    directions: string;\n    lastCheckedTweetId: bigint | null = null;\n    imageDescriptionService: IImageDescriptionService;\n    temperature: number = 0.5;\n\n    requestQueue: RequestQueue = new RequestQueue();\n\n    profile: TwitterProfile | null;\n\n    async cacheTweet(tweet: Tweet): Promise<void> {\n        if (!tweet) {\n            console.warn(\"Tweet is undefined, skipping cache\");\n            return;\n        }\n\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n    }\n\n    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n        const cached = await this.runtime.cacheManager.get<Tweet>(\n            `twitter/tweets/${tweetId}`\n        );\n\n        return cached;\n    }\n\n    async getTweet(tweetId: string): Promise<Tweet> {\n        const cachedTweet = await this.getCachedTweet(tweetId);\n\n        if (cachedTweet) {\n            return cachedTweet;\n        }\n\n        const tweet = await this.requestQueue.add(() =>\n            this.twitterClient.getTweet(tweetId)\n        );\n\n        await this.cacheTweet(tweet);\n        return tweet;\n    }\n\n    callback: (self: ClientBase) => any = null;\n\n    onReady() {\n        throw new Error(\n            \"Not implemented in base class, please call from subclass\"\n        );\n    }\n\n    constructor(runtime: IAgentRuntime) {\n        super();\n        this.runtime = runtime;\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n        if (ClientBase._twitterClients[username]) {\n            this.twitterClient = ClientBase._twitterClients[username];\n        } else {\n            this.twitterClient = new Scraper();\n            ClientBase._twitterClients[username] = this.twitterClient;\n        }\n\n        this.directions =\n            \"- \" +\n            this.runtime.character.style.all.join(\"\\n- \") +\n            \"- \" +\n            this.runtime.character.style.post.join();\n    }\n\n    async init() {\n        //test\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n        const password = this.runtime.getSetting(\"TWITTER_PASSWORD\");\n        const email = this.runtime.getSetting(\"TWITTER_EMAIL\");\n        let retries = parseInt(\n            this.runtime.getSetting(\"TWITTER_RETRY_LIMIT\") || \"5\",\n            10\n        );\n        const twitter2faSecret =\n            this.runtime.getSetting(\"TWITTER_2FA_SECRET\") || undefined;\n        const cookies = this.runtime.getSetting(\"TWITTER_COOKIES\");\n\n        if (!username) {\n            throw new Error(\"Twitter username not configured\");\n        }\n        // Check for Twitter cookies\n        if (cookies) {\n            elizaLogger.debug(\"Using cookies from settings\");\n            const cookiesArray = JSON.parse(cookies);\n\n            await this.setCookiesFromArray(cookiesArray);\n        } else {\n            elizaLogger.debug(\"No cookies found in settings\");\n            elizaLogger.debug(\"Checking for cached cookies\");\n            const cachedCookies = await this.getCachedCookies(username);\n            if (cachedCookies) {\n                await this.setCookiesFromArray(cachedCookies);\n            }\n        }\n\n        elizaLogger.log(\"Waiting for Twitter login\");\n        while (retries > 0) {\n            const cookies = await this.twitterClient.getCookies();\n            if ((await this.twitterClient.isLoggedIn()) && !!cookies) {\n                elizaLogger.info(\"Already logged in.\");\n                await this.cacheCookies(username, cookies);\n                elizaLogger.info(\"Successfully logged in and cookies cached.\");\n                break;\n            }\n\n            try {\n                await this.twitterClient.login(\n                    username,\n                    password,\n                    email,\n                    twitter2faSecret\n                );\n            } catch (error) {\n                elizaLogger.error(`Login attempt failed: ${error.message}`);\n            }\n\n            retries--;\n            elizaLogger.error(\n                `Failed to login to Twitter. Retrying... (${retries} attempts left)`\n            );\n\n            if (retries === 0) {\n                elizaLogger.error(\n                    \"Max retries reached. Exiting login process.\"\n                );\n                throw new Error(\"Twitter login failed after maximum retries.\");\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, 2000));\n        }\n        // Initialize Twitter profile\n        this.profile = await this.fetchProfile(username);\n\n        if (this.profile) {\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\n            elizaLogger.log(\n                \"Twitter loaded:\",\n                JSON.stringify(this.profile, null, 10)\n            );\n            // Store profile info for use in responses\n            this.runtime.character.twitterProfile = {\n                id: this.profile.id,\n                username: this.profile.username,\n                screenName: this.profile.screenName,\n                bio: this.profile.bio,\n                nicknames: this.profile.nicknames,\n            };\n        } else {\n            throw new Error(\"Failed to load profile\");\n        }\n\n        await this.loadLatestCheckedTweetId();\n        await this.populateTimeline();\n    }\n\n    async fetchOwnPosts(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching own posts\");\n        const homeTimeline = await this.twitterClient.getUserTweets(\n            this.profile.id,\n            count\n        );\n        return homeTimeline.tweets;\n    }\n\n    async fetchHomeTimeline(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching home timeline\");\n        const homeTimeline = await this.twitterClient.fetchHomeTimeline(\n            count,\n            []\n        );\n\n        elizaLogger.debug(homeTimeline, { depth: Infinity });\n        const processedTimeline = homeTimeline\n            .filter((t) => t.__typename !== \"TweetWithVisibilityResults\") // what's this about?\n            .map((tweet) => {\n                //console.log(\"tweet is\", tweet);\n                const obj = {\n                    id: tweet.id,\n                    name:\n                        tweet.name ?? tweet?.user_results?.result?.legacy.name,\n                    username:\n                        tweet.username ??\n                        tweet.core?.user_results?.result?.legacy.screen_name,\n                    text: tweet.text ?? tweet.legacy?.full_text,\n                    inReplyToStatusId:\n                        tweet.inReplyToStatusId ??\n                        tweet.legacy?.in_reply_to_status_id_str ??\n                        null,\n                    timestamp:\n                        new Date(tweet.legacy?.created_at).getTime() / 1000,\n                    createdAt:\n                        tweet.createdAt ??\n                        tweet.legacy?.created_at ??\n                        tweet.core?.user_results?.result?.legacy.created_at,\n                    userId: tweet.userId ?? tweet.legacy?.user_id_str,\n                    conversationId:\n                        tweet.conversationId ??\n                        tweet.legacy?.conversation_id_str,\n                    permanentUrl: `https://x.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n                    hashtags: tweet.hashtags ?? tweet.legacy?.entities.hashtags,\n                    mentions:\n                        tweet.mentions ?? tweet.legacy?.entities.user_mentions,\n                    photos:\n                        tweet.photos ??\n                        tweet.legacy?.entities.media?.filter(\n                            (media) => media.type === \"photo\"\n                        ) ??\n                        [],\n                    thread: tweet.thread || [],\n                    urls: tweet.urls ?? tweet.legacy?.entities.urls,\n                    videos:\n                        tweet.videos ??\n                        tweet.legacy?.entities.media?.filter(\n                            (media) => media.type === \"video\"\n                        ) ??\n                        [],\n                };\n                //console.log(\"obj is\", obj);\n                return obj;\n            });\n        //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\n        return processedTimeline;\n    }\n\n    async fetchTimelineForActions(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching timeline for actions\");\n        const homeTimeline = await this.twitterClient.fetchHomeTimeline(\n            count,\n            []\n        );\n\n        return homeTimeline.map((tweet) => ({\n            id: tweet.rest_id,\n            name: tweet.core?.user_results?.result?.legacy?.name,\n            username: tweet.core?.user_results?.result?.legacy?.screen_name,\n            text: tweet.legacy?.full_text,\n            inReplyToStatusId: tweet.legacy?.in_reply_to_status_id_str,\n            timestamp: new Date(tweet.legacy?.created_at).getTime() / 1000,\n            userId: tweet.legacy?.user_id_str,\n            conversationId: tweet.legacy?.conversation_id_str,\n            permanentUrl: `https://twitter.com/${tweet.core?.user_results?.result?.legacy?.screen_name}/status/${tweet.rest_id}`,\n            hashtags: tweet.legacy?.entities?.hashtags || [],\n            mentions: tweet.legacy?.entities?.user_mentions || [],\n            photos:\n                tweet.legacy?.entities?.media?.filter(\n                    (media) => media.type === \"photo\"\n                ) || [],\n            thread: tweet.thread || [],\n            urls: tweet.legacy?.entities?.urls || [],\n            videos:\n                tweet.legacy?.entities?.media?.filter(\n                    (media) => media.type === \"video\"\n                ) || [],\n        }));\n    }\n\n    async fetchSearchTweets(\n        query: string,\n        maxTweets: number,\n        searchMode: SearchMode,\n        cursor?: string\n    ): Promise<QueryTweetsResponse> {\n        try {\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n            // if we dont get a response in 5 seconds, something is wrong\n            const timeoutPromise = new Promise((resolve) =>\n                setTimeout(() => resolve({ tweets: [] }), 10000)\n            );\n\n            try {\n                const result = await this.requestQueue.add(\n                    async () =>\n                        await Promise.race([\n                            this.twitterClient.fetchSearchTweets(\n                                query,\n                                maxTweets,\n                                searchMode,\n                                cursor\n                            ),\n                            timeoutPromise,\n                        ])\n                );\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching search tweets:\", error);\n                return { tweets: [] };\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error fetching search tweets:\", error);\n            return { tweets: [] };\n        }\n    }\n\n    private async populateTimeline() {\n        elizaLogger.debug(\"populating timeline...\");\n\n        const cachedTimeline = await this.getCachedTimeline();\n\n        // Check if the cache file exists\n        if (cachedTimeline) {\n            // Read the cached search results from the file\n\n            // Get the existing memories from the database\n            const existingMemories =\n                await this.runtime.messageManager.getMemoriesByRoomIds({\n                    roomIds: cachedTimeline.map((tweet) =>\n                        stringToUuid(\n                            tweet.conversationId + \"-\" + this.runtime.agentId\n                        )\n                    ),\n                });\n\n            //TODO: load tweets not in cache?\n\n            // Create a Set to store the IDs of existing memories\n            const existingMemoryIds = new Set(\n                existingMemories.map((memory) => memory.id.toString())\n            );\n\n            // Check if any of the cached tweets exist in the existing memories\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n                existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n            );\n\n            if (someCachedTweetsExist) {\n                // Filter out the cached tweets that already exist in the database\n                const tweetsToSave = cachedTimeline.filter(\n                    (tweet) =>\n                        !existingMemoryIds.has(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        )\n                );\n\n                console.log({\n                    processingTweets: tweetsToSave\n                        .map((tweet) => tweet.id)\n                        .join(\",\"),\n                });\n\n                // Save the missing tweets as memories\n                for (const tweet of tweetsToSave) {\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userId =\n                        tweet.userId === this.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId);\n\n                    if (tweet.userId === this.profile.id) {\n                        await this.runtime.ensureConnection(\n                            this.runtime.agentId,\n                            roomId,\n                            this.profile.username,\n                            this.profile.screenName,\n                            \"twitter\"\n                        );\n                    } else {\n                        await this.runtime.ensureConnection(\n                            userId,\n                            roomId,\n                            tweet.username,\n                            tweet.name,\n                            \"twitter\"\n                        );\n                    }\n\n                    const content = {\n                        text: tweet.text,\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                        inReplyTo: tweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  tweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    } as Content;\n\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\n\n                    // check if it already exists\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n\n                    if (memory) {\n                        elizaLogger.log(\n                            \"Memory already exists, skipping timeline population\"\n                        );\n                        break;\n                    }\n\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId,\n                        content: content,\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    await this.cacheTweet(tweet);\n                }\n\n                elizaLogger.log(\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\n                );\n                return;\n            }\n        }\n\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n        const username = this.runtime.getSetting(\"TWITTER_USERNAME\");\n\n        // Get the most recent 20 mentions and interactions\n        const mentionsAndInteractions = await this.fetchSearchTweets(\n            `@${username}`,\n            20,\n            SearchMode.Latest\n        );\n\n        // Combine the timeline tweets and mentions/interactions\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n        // Create a Set to store unique tweet IDs\n        const tweetIdsToCheck = new Set<string>();\n        const roomIds = new Set<UUID>();\n\n        // Add tweet IDs to the Set\n        for (const tweet of allTweets) {\n            tweetIdsToCheck.add(tweet.id);\n            roomIds.add(\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\n            );\n        }\n\n        // Check the existing memories in the database\n        const existingMemories =\n            await this.runtime.messageManager.getMemoriesByRoomIds({\n                roomIds: Array.from(roomIds),\n            });\n\n        // Create a Set to store the existing memory IDs\n        const existingMemoryIds = new Set<UUID>(\n            existingMemories.map((memory) => memory.id)\n        );\n\n        // Filter out the tweets that already exist in the database\n        const tweetsToSave = allTweets.filter(\n            (tweet) =>\n                !existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n        );\n\n        elizaLogger.debug({\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\n        });\n\n        await this.runtime.ensureUserExists(\n            this.runtime.agentId,\n            this.profile.username,\n            this.runtime.character.name,\n            \"twitter\"\n        );\n\n        // Save the new tweets as memories\n        for (const tweet of tweetsToSave) {\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n            const roomId = stringToUuid(\n                tweet.conversationId + \"-\" + this.runtime.agentId\n            );\n            const userId =\n                tweet.userId === this.profile.id\n                    ? this.runtime.agentId\n                    : stringToUuid(tweet.userId);\n\n            if (tweet.userId === this.profile.id) {\n                await this.runtime.ensureConnection(\n                    this.runtime.agentId,\n                    roomId,\n                    this.profile.username,\n                    this.profile.screenName,\n                    \"twitter\"\n                );\n            } else {\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n            }\n\n            const content = {\n                text: tweet.text,\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n                inReplyTo: tweet.inReplyToStatusId\n                    ? stringToUuid(tweet.inReplyToStatusId)\n                    : undefined,\n            } as Content;\n\n            await this.runtime.messageManager.createMemory({\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                userId,\n                content: content,\n                agentId: this.runtime.agentId,\n                roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: tweet.timestamp * 1000,\n            });\n\n            await this.cacheTweet(tweet);\n        }\n\n        // Cache\n        await this.cacheTimeline(timeline);\n        await this.cacheMentions(mentionsAndInteractions.tweets);\n    }\n\n    async setCookiesFromArray(cookiesArray: any[]) {\n        const cookieStrings = cookiesArray.map(\n            (cookie) =>\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n                    cookie.secure ? \"Secure\" : \"\"\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\n                    cookie.sameSite || \"Lax\"\n                }`\n        );\n        await this.twitterClient.setCookies(cookieStrings);\n    }\n\n    async saveRequestMessage(message: Memory, state: State) {\n        if (message.content.text) {\n            const recentMessage = await this.runtime.messageManager.getMemories(\n                {\n                    roomId: message.roomId,\n                    count: 1,\n                    unique: false,\n                }\n            );\n\n            if (\n                recentMessage.length > 0 &&\n                recentMessage[0].content === message.content\n            ) {\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\n            } else {\n                await this.runtime.messageManager.createMemory({\n                    ...message,\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            await this.runtime.evaluate(message, {\n                ...state,\n                twitterClient: this.twitterClient,\n            });\n        }\n    }\n\n    async loadLatestCheckedTweetId(): Promise<void> {\n        const latestCheckedTweetId =\n            await this.runtime.cacheManager.get<string>(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\n            );\n\n        if (latestCheckedTweetId) {\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n        }\n    }\n\n    async cacheLatestCheckedTweetId() {\n        if (this.lastCheckedTweetId) {\n            await this.runtime.cacheManager.set(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\n                this.lastCheckedTweetId.toString()\n            );\n        }\n    }\n\n    async getCachedTimeline(): Promise<Tweet[] | undefined> {\n        return await this.runtime.cacheManager.get<Tweet[]>(\n            `twitter/${this.profile.username}/timeline`\n        );\n    }\n\n    async cacheTimeline(timeline: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/timeline`,\n            timeline,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async cacheMentions(mentions: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/mentions`,\n            mentions,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async getCachedCookies(username: string) {\n        return await this.runtime.cacheManager.get<any[]>(\n            `twitter/${username}/cookies`\n        );\n    }\n\n    async cacheCookies(username: string, cookies: any[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${username}/cookies`,\n            cookies\n        );\n    }\n\n    async getCachedProfile(username: string) {\n        return await this.runtime.cacheManager.get<TwitterProfile>(\n            `twitter/${username}/profile`\n        );\n    }\n\n    async cacheProfile(profile: TwitterProfile) {\n        await this.runtime.cacheManager.set(\n            `twitter/${profile.username}/profile`,\n            profile\n        );\n    }\n\n    async fetchProfile(username: string): Promise<TwitterProfile> {\n        const cached = await this.getCachedProfile(username);\n\n        if (cached) return cached;\n\n        try {\n            const profile = await this.requestQueue.add(async () => {\n                const profile = await this.twitterClient.getProfile(username);\n                // console.log({ profile });\n                return {\n                    id: profile.userId,\n                    username,\n                    screenName: profile.name || this.runtime.character.name,\n                    bio:\n                        profile.biography ||\n                        typeof this.runtime.character.bio === \"string\"\n                            ? (this.runtime.character.bio as string)\n                            : this.runtime.character.bio.length > 0\n                              ? this.runtime.character.bio[0]\n                              : \"\",\n                    nicknames:\n                        this.runtime.character.twitterProfile?.nicknames || [],\n                } satisfies TwitterProfile;\n            });\n\n            this.cacheProfile(profile);\n\n            return profile;\n        } catch (error) {\n            console.error(\"Error fetching Twitter profile:\", error);\n\n            return undefined;\n        }\n    }\n}\n","import { IAgentRuntime } from \"@ai16z/eliza\";\nimport { z } from \"zod\";\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nexport const twitterEnvSchema = z.object({\n    TWITTER_DRY_RUN: z\n        .string()\n        .transform((val) => val.toLowerCase() === \"true\"),\n    TWITTER_USERNAME: z.string().min(1, \"Twitter username is required\"),\n    TWITTER_PASSWORD: z.string().min(1, \"Twitter password is required\"),\n    TWITTER_EMAIL: z.string().email(\"Valid Twitter email is required\"),\n    TWITTER_COOKIES: z.string().optional(),\n    MAX_TWEET_LENGTH: z\n        .string()\n        .pipe(z.coerce.number().min(0).int())\n        .default(DEFAULT_MAX_TWEET_LENGTH.toString()),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\nexport async function validateTwitterConfig(\n    runtime: IAgentRuntime\n): Promise<TwitterConfig> {\n    try {\n        const twitterConfig = {\n            TWITTER_DRY_RUN:\n                runtime.getSetting(\"TWITTER_DRY_RUN\") ||\n                process.env.TWITTER_DRY_RUN ||\n                \"false\",\n            TWITTER_USERNAME:\n                runtime.getSetting(\"TWITTER_USERNAME\") ||\n                process.env.TWITTER_USERNAME,\n            TWITTER_PASSWORD:\n                runtime.getSetting(\"TWITTER_PASSWORD\") ||\n                process.env.TWITTER_PASSWORD,\n            TWITTER_EMAIL:\n                runtime.getSetting(\"TWITTER_EMAIL\") ||\n                process.env.TWITTER_EMAIL,\n            TWITTER_COOKIES:\n                runtime.getSetting(\"TWITTER_COOKIES\") ||\n                process.env.TWITTER_COOKIES,\n            MAX_TWEET_LENGTH:\n                runtime.getSetting(\"MAX_TWEET_LENGTH\") ||\n                process.env.MAX_TWEET_LENGTH ||\n                DEFAULT_MAX_TWEET_LENGTH.toString(),\n        };\n\n        return twitterEnvSchema.parse(twitterConfig);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Twitter configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { SearchMode, Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    Content,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n} from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base.ts\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nexport const twitterMessageHandlerTemplate =\n    `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# Task: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n{{actions}}\n# Task: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\n{{recentPosts}}\n\nIMPORTANT: For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\n{{recentPosts}}\n\nIMPORTANT: {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n    }\n\n    async start() {\n        const handleTwitterInteractionsLoop = () => {\n            this.handleTwitterInteractions();\n            setTimeout(\n                handleTwitterInteractionsLoop,\n                Number(\n                    this.runtime.getSetting(\"TWITTER_POLL_INTERVAL\") || 120\n                ) * 1000 // Default to 2 minutes\n            );\n        };\n        handleTwitterInteractionsLoop();\n    }\n\n    async handleTwitterInteractions() {\n        elizaLogger.log(\"Checking Twitter interactions\");\n        // Read from environment variable, fallback to default list if not set\n        const targetUsersStr = this.runtime.getSetting(\"TWITTER_TARGET_USERS\");\n\n        const twitterUsername = this.client.profile.username;\n        try {\n            // Check for mentions\n            const mentionCandidates = (\n                await this.client.fetchSearchTweets(\n                    `@${twitterUsername}`,\n                    20,\n                    SearchMode.Latest\n                )\n            ).tweets;\n\n            elizaLogger.log(\n                \"Completed checking mentioned tweets:\",\n                mentionCandidates.length\n            );\n            let uniqueTweetCandidates = [...mentionCandidates];\n            // Only process target users if configured\n            if (targetUsersStr && targetUsersStr.trim()) {\n                const TARGET_USERS = targetUsersStr\n                    .split(\",\")\n                    .map((u) => u.trim())\n                    .filter((u) => u.length > 0); // Filter out empty strings after split\n\n                elizaLogger.log(\"Processing target users:\", TARGET_USERS);\n\n                if (TARGET_USERS.length > 0) {\n                    // Create a map to store tweets by user\n                    const tweetsByUser = new Map<string, Tweet[]>();\n\n                    // Fetch tweets from all target users\n                    for (const username of TARGET_USERS) {\n                        try {\n                            const userTweets = (\n                                await this.client.twitterClient.fetchSearchTweets(\n                                    `from:${username}`,\n                                    3,\n                                    SearchMode.Latest\n                                )\n                            ).tweets;\n\n                            // Filter for unprocessed, non-reply, recent tweets\n                            const validTweets = userTweets.filter((tweet) => {\n                                const isUnprocessed =\n                                    !this.client.lastCheckedTweetId ||\n                                    parseInt(tweet.id) >\n                                        this.client.lastCheckedTweetId;\n                                const isRecent =\n                                    Date.now() - tweet.timestamp * 1000 <\n                                    2 * 60 * 60 * 1000;\n\n                                elizaLogger.log(`Tweet ${tweet.id} checks:`, {\n                                    isUnprocessed,\n                                    isRecent,\n                                    isReply: tweet.isReply,\n                                    isRetweet: tweet.isRetweet,\n                                });\n\n                                return (\n                                    isUnprocessed &&\n                                    !tweet.isReply &&\n                                    !tweet.isRetweet &&\n                                    isRecent\n                                );\n                            });\n\n                            if (validTweets.length > 0) {\n                                tweetsByUser.set(username, validTweets);\n                                elizaLogger.log(\n                                    `Found ${validTweets.length} valid tweets from ${username}`\n                                );\n                            }\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error fetching tweets for ${username}:`,\n                                error\n                            );\n                            continue;\n                        }\n                    }\n\n                    // Select one tweet from each user that has tweets\n                    const selectedTweets: Tweet[] = [];\n                    for (const [username, tweets] of tweetsByUser) {\n                        if (tweets.length > 0) {\n                            // Randomly select one tweet from this user\n                            const randomTweet =\n                                tweets[\n                                    Math.floor(Math.random() * tweets.length)\n                                ];\n                            selectedTweets.push(randomTweet);\n                            elizaLogger.log(\n                                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`\n                            );\n                        }\n                    }\n\n                    // Add selected tweets to candidates\n                    uniqueTweetCandidates = [\n                        ...mentionCandidates,\n                        ...selectedTweets,\n                    ];\n                }\n            } else {\n                elizaLogger.log(\n                    \"No target users configured, processing only mentions\"\n                );\n            }\n\n            // Sort tweet candidates by ID in ascending order\n            uniqueTweetCandidates\n                .sort((a, b) => a.id.localeCompare(b.id))\n                .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n            // for each tweet candidate, handle the tweet\n            for (const tweet of uniqueTweetCandidates) {\n                if (\n                    !this.client.lastCheckedTweetId ||\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\n                ) {\n                    // Generate the tweetId UUID the same way it's done in handleTweet\n                    const tweetId = stringToUuid(\n                        tweet.id + \"-\" + this.runtime.agentId\n                    );\n\n                    // Check if we've already processed this tweet\n                    const existingResponse =\n                        await this.runtime.messageManager.getMemoryById(\n                            tweetId\n                        );\n\n                    if (existingResponse) {\n                        elizaLogger.log(\n                            `Already responded to tweet ${tweet.id}, skipping`\n                        );\n                        continue;\n                    }\n                    elizaLogger.log(\"New Tweet found\", tweet.permanentUrl);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userIdUUID =\n                        tweet.userId === this.client.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId!);\n\n                    await this.runtime.ensureConnection(\n                        userIdUUID,\n                        roomId,\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n\n                    const thread = await buildConversationThread(\n                        tweet,\n                        this.client\n                    );\n\n                    const message = {\n                        content: { text: tweet.text },\n                        agentId: this.runtime.agentId,\n                        userId: userIdUUID,\n                        roomId,\n                    };\n\n                    await this.handleTweet({\n                        tweet,\n                        message,\n                        thread,\n                    });\n\n                    // Update the last checked tweet ID after processing each tweet\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\n                }\n            }\n\n            // Save the latest checked tweet ID to the file\n            await this.client.cacheLatestCheckedTweetId();\n\n            elizaLogger.log(\"Finished checking Twitter interactions\");\n        } catch (error) {\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\n        }\n    }\n\n    private async handleTweet({\n        tweet,\n        message,\n        thread,\n    }: {\n        tweet: Tweet;\n        message: Memory;\n        thread: Tweet[];\n    }) {\n        if (tweet.userId === this.client.profile.id) {\n            // console.log(\"skipping tweet from bot itself\", tweet.id);\n            // Skip processing if the tweet is from the bot itself\n            return;\n        }\n\n        if (!message.content.text) {\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\n        const formatTweet = (tweet: Tweet) => {\n            return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n        };\n        const currentPost = formatTweet(tweet);\n\n        elizaLogger.debug(\"Thread: \", thread);\n        const formattedConversation = thread\n            .map(\n                (tweet) => `@${tweet.username} (${new Date(\n                    tweet.timestamp * 1000\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n        ${tweet.text}`\n            )\n            .join(\"\\n\\n\");\n\n        elizaLogger.debug(\"formattedConversation: \", formattedConversation);\n\n        let state = await this.runtime.composeState(message, {\n            twitterClient: this.client.twitterClient,\n            twitterUserName: this.runtime.getSetting(\"TWITTER_USERNAME\"),\n            currentPost,\n            formattedConversation,\n        });\n\n        // check if the tweet exists, save if it doesn't\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n        const tweetExists =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n        if (!tweetExists) {\n            elizaLogger.log(\"tweet does not exist, saving\");\n            const userIdUUID = stringToUuid(tweet.userId as string);\n            const roomId = stringToUuid(tweet.conversationId);\n\n            const message = {\n                id: tweetId,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: tweet.text,\n                    url: tweet.permanentUrl,\n                    inReplyTo: tweet.inReplyToStatusId\n                        ? stringToUuid(\n                              tweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                createdAt: tweet.timestamp * 1000,\n            };\n            this.client.saveRequestMessage(message, state);\n        }\n\n        // 1. Get the raw target users string from settings\n        const targetUsersStr = this.runtime.getSetting(\"TWITTER_TARGET_USERS\");\n\n        // 2. Process the string to get valid usernames\n        const validTargetUsersStr =\n            targetUsersStr && targetUsersStr.trim()\n                ? targetUsersStr\n                      .split(\",\") // Split by commas: \"user1,user2\" -> [\"user1\", \"user2\"]\n                      .map((u) => u.trim()) // Remove whitespace: [\" user1 \", \"user2 \"] -> [\"user1\", \"user2\"]\n                      .filter((u) => u.length > 0)\n                      .join(\",\")\n                : \"\";\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.twitterShouldRespondTemplate ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                twitterShouldRespondTemplate(validTargetUsersStr),\n        });\n\n        const shouldRespond = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.MEDIUM,\n        });\n\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n        if (shouldRespond !== \"RESPOND\") {\n            elizaLogger.log(\"Not responding to message\");\n            return { text: \"Response Decision:\", action: shouldRespond };\n        }\n\n        const context = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                this.runtime.character?.templates?.messageHandlerTemplate ||\n                twitterMessageHandlerTemplate,\n        });\n\n        elizaLogger.debug(\"Interactions prompt:\\n\" + context);\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        const removeQuotes = (str: string) =>\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n\n        response.inReplyTo = stringId;\n\n        response.text = removeQuotes(response.text);\n\n        if (response.text) {\n            try {\n                const callback: HandlerCallback = async (response: Content) => {\n                    const memories = await sendTweet(\n                        this.client,\n                        response,\n                        message.roomId,\n                        this.runtime.getSetting(\"TWITTER_USERNAME\"),\n                        tweet.id\n                    );\n                    return memories;\n                };\n\n                const responseMessages = await callback(response);\n\n                state = (await this.runtime.updateRecentMessageState(\n                    state\n                )) as State;\n\n                for (const responseMessage of responseMessages) {\n                    if (\n                        responseMessage ===\n                        responseMessages[responseMessages.length - 1]\n                    ) {\n                        responseMessage.content.action = response.action;\n                    } else {\n                        responseMessage.content.action = \"CONTINUE\";\n                    }\n                    await this.runtime.messageManager.createMemory(\n                        responseMessage\n                    );\n                }\n\n                await this.runtime.processActions(\n                    message,\n                    responseMessages,\n                    state,\n                    callback\n                );\n\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/tweet_generation_${tweet.id}.txt`,\n                    responseInfo\n                );\n                await wait();\n            } catch (error) {\n                elizaLogger.error(`Error sending response tweet: ${error}`);\n            }\n        }\n    }\n\n    async buildConversationThread(\n        tweet: Tweet,\n        maxReplies: number = 10\n    ): Promise<Tweet[]> {\n        const thread: Tweet[] = [];\n        const visited: Set<string> = new Set();\n\n        async function processThread(currentTweet: Tweet, depth: number = 0) {\n            elizaLogger.log(\"Processing tweet:\", {\n                id: currentTweet.id,\n                inReplyToStatusId: currentTweet.inReplyToStatusId,\n                depth: depth,\n            });\n\n            if (!currentTweet) {\n                elizaLogger.log(\"No current tweet found for thread building\");\n                return;\n            }\n\n            if (depth >= maxReplies) {\n                elizaLogger.log(\"Reached maximum reply depth\", depth);\n                return;\n            }\n\n            // Handle memory storage\n            const memory = await this.runtime.messageManager.getMemoryById(\n                stringToUuid(currentTweet.id + \"-\" + this.runtime.agentId)\n            );\n            if (!memory) {\n                const roomId = stringToUuid(\n                    currentTweet.conversationId + \"-\" + this.runtime.agentId\n                );\n                const userId = stringToUuid(currentTweet.userId);\n\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    currentTweet.username,\n                    currentTweet.name,\n                    \"twitter\"\n                );\n\n                this.runtime.messageManager.createMemory({\n                    id: stringToUuid(\n                        currentTweet.id + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: currentTweet.text,\n                        source: \"twitter\",\n                        url: currentTweet.permanentUrl,\n                        inReplyTo: currentTweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  currentTweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    },\n                    createdAt: currentTweet.timestamp * 1000,\n                    roomId,\n                    userId:\n                        currentTweet.userId === this.twitterUserId\n                            ? this.runtime.agentId\n                            : stringToUuid(currentTweet.userId),\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            if (visited.has(currentTweet.id)) {\n                elizaLogger.log(\"Already visited tweet:\", currentTweet.id);\n                return;\n            }\n\n            visited.add(currentTweet.id);\n            thread.unshift(currentTweet);\n\n            elizaLogger.debug(\"Current thread state:\", {\n                length: thread.length,\n                currentDepth: depth,\n                tweetId: currentTweet.id,\n            });\n\n            if (currentTweet.inReplyToStatusId) {\n                elizaLogger.log(\n                    \"Fetching parent tweet:\",\n                    currentTweet.inReplyToStatusId\n                );\n                try {\n                    const parentTweet = await this.twitterClient.getTweet(\n                        currentTweet.inReplyToStatusId\n                    );\n\n                    if (parentTweet) {\n                        elizaLogger.log(\"Found parent tweet:\", {\n                            id: parentTweet.id,\n                            text: parentTweet.text?.slice(0, 50),\n                        });\n                        await processThread(parentTweet, depth + 1);\n                    } else {\n                        elizaLogger.log(\n                            \"No parent tweet found for:\",\n                            currentTweet.inReplyToStatusId\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.log(\"Error fetching parent tweet:\", {\n                        tweetId: currentTweet.inReplyToStatusId,\n                        error,\n                    });\n                }\n            } else {\n                elizaLogger.log(\n                    \"Reached end of reply chain at:\",\n                    currentTweet.id\n                );\n            }\n        }\n\n        // Need to bind this context for the inner function\n        await processThread.bind(this)(tweet, 0);\n\n        elizaLogger.debug(\"Final thread built:\", {\n            totalTweets: thread.length,\n            tweetIds: thread.map((t) => ({\n                id: t.id,\n                text: t.text?.slice(0, 50),\n            })),\n        });\n\n        return thread;\n    }\n}\n","import { Tweet } from \"agent-twitter-client\";\nimport { getEmbeddingZeroVector } from \"@ai16z/eliza\";\nimport { Content, Memory, UUID } from \"@ai16z/eliza\";\nimport { stringToUuid } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport { DEFAULT_MAX_TWEET_LENGTH } from \"./environment\";\nimport { Media } from \"@ai16z/eliza\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nexport const wait = (minTime: number = 1000, maxTime: number = 3000) => {\n    const waitTime =\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n    const atCount = (tweet.text?.match(/@/g) || []).length;\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n    const totalCount = hashtagCount + atCount + dollarSignCount;\n\n    return (\n        hashtagCount <= 1 &&\n        atCount <= 2 &&\n        dollarSignCount <= 1 &&\n        totalCount <= 3\n    );\n};\n\nexport async function buildConversationThread(\n    tweet: Tweet,\n    client: ClientBase,\n    maxReplies: number = 10\n): Promise<Tweet[]> {\n    const thread: Tweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: Tweet, depth: number = 0) {\n        elizaLogger.debug(\"Processing tweet:\", {\n            id: currentTweet.id,\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\n            depth: depth,\n        });\n\n        if (!currentTweet) {\n            elizaLogger.debug(\"No current tweet found for thread building\");\n            return;\n        }\n\n        // Stop if we've reached our reply limit\n        if (depth >= maxReplies) {\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\n            return;\n        }\n\n        // Handle memory storage\n        const memory = await client.runtime.messageManager.getMemoryById(\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\n        );\n        if (!memory) {\n            const roomId = stringToUuid(\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\n            );\n            const userId = stringToUuid(currentTweet.userId);\n\n            await client.runtime.ensureConnection(\n                userId,\n                roomId,\n                currentTweet.username,\n                currentTweet.name,\n                \"twitter\"\n            );\n\n            await client.runtime.messageManager.createMemory({\n                id: stringToUuid(\n                    currentTweet.id + \"-\" + client.runtime.agentId\n                ),\n                agentId: client.runtime.agentId,\n                content: {\n                    text: currentTweet.text,\n                    source: \"twitter\",\n                    url: currentTweet.permanentUrl,\n                    inReplyTo: currentTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              currentTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  client.runtime.agentId\n                          )\n                        : undefined,\n                },\n                createdAt: currentTweet.timestamp * 1000,\n                roomId,\n                userId:\n                    currentTweet.userId === client.profile.id\n                        ? client.runtime.agentId\n                        : stringToUuid(currentTweet.userId),\n                embedding: getEmbeddingZeroVector(),\n            });\n        }\n\n        if (visited.has(currentTweet.id)) {\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\n            return;\n        }\n\n        visited.add(currentTweet.id);\n        thread.unshift(currentTweet);\n\n        elizaLogger.debug(\"Current thread state:\", {\n            length: thread.length,\n            currentDepth: depth,\n            tweetId: currentTweet.id,\n        });\n\n        // If there's a parent tweet, fetch and process it\n        if (currentTweet.inReplyToStatusId) {\n            elizaLogger.debug(\n                \"Fetching parent tweet:\",\n                currentTweet.inReplyToStatusId\n            );\n            try {\n                const parentTweet = await client.twitterClient.getTweet(\n                    currentTweet.inReplyToStatusId\n                );\n\n                if (parentTweet) {\n                    elizaLogger.debug(\"Found parent tweet:\", {\n                        id: parentTweet.id,\n                        text: parentTweet.text?.slice(0, 50),\n                    });\n                    await processThread(parentTweet, depth + 1);\n                } else {\n                    elizaLogger.debug(\n                        \"No parent tweet found for:\",\n                        currentTweet.inReplyToStatusId\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error fetching parent tweet:\", {\n                    tweetId: currentTweet.inReplyToStatusId,\n                    error,\n                });\n            }\n        } else {\n            elizaLogger.debug(\n                \"Reached end of reply chain at:\",\n                currentTweet.id\n            );\n        }\n    }\n\n    await processThread(tweet, 0);\n\n    elizaLogger.debug(\"Final thread built:\", {\n        totalTweets: thread.length,\n        tweetIds: thread.map((t) => ({\n            id: t.id,\n            text: t.text?.slice(0, 50),\n        })),\n    });\n\n    return thread;\n}\n\nexport async function sendTweet(\n    client: ClientBase,\n    content: Content,\n    roomId: UUID,\n    twitterUsername: string,\n    inReplyTo: string\n): Promise<Memory[]> {\n    const tweetChunks = splitTweetContent(\n        content.text,\n        Number(client.runtime.getSetting(\"MAX_TWEET_LENGTH\")) ||\n            DEFAULT_MAX_TWEET_LENGTH\n    );\n    const sentTweets: Tweet[] = [];\n    let previousTweetId = inReplyTo;\n\n    for (const chunk of tweetChunks) {\n        let mediaData: { data: Buffer; mediaType: string }[] | undefined;\n\n        if (content.attachments && content.attachments.length > 0) {\n            mediaData = await Promise.all(\n                content.attachments.map(async (attachment: Media) => {\n                    if (/^(http|https):\\/\\//.test(attachment.url)) {\n                        // Handle HTTP URLs\n                        const response = await fetch(attachment.url);\n                        if (!response.ok) {\n                            throw new Error(\n                                `Failed to fetch file: ${attachment.url}`\n                            );\n                        }\n                        const mediaBuffer = Buffer.from(\n                            await response.arrayBuffer()\n                        );\n                        const mediaType = attachment.contentType;\n                        return { data: mediaBuffer, mediaType };\n                    } else if (fs.existsSync(attachment.url)) {\n                        // Handle local file paths\n                        const mediaBuffer = await fs.promises.readFile(\n                            path.resolve(attachment.url)\n                        );\n                        const mediaType = attachment.contentType;\n                        return { data: mediaBuffer, mediaType };\n                    } else {\n                        throw new Error(\n                            `File not found: ${attachment.url}. Make sure the path is correct.`\n                        );\n                    }\n                })\n            );\n        }\n        const result = await client.requestQueue.add(\n            async () =>\n                await client.twitterClient.sendTweet(\n                    chunk.trim(),\n                    previousTweetId,\n                    mediaData\n                )\n        );\n        const body = await result.json();\n\n        // if we have a response\n        if (body?.data?.create_tweet?.tweet_results?.result) {\n            // Parse the response\n            const tweetResult = body.data.create_tweet.tweet_results.result;\n            const finalTweet: Tweet = {\n                id: tweetResult.rest_id,\n                text: tweetResult.legacy.full_text,\n                conversationId: tweetResult.legacy.conversation_id_str,\n                timestamp:\n                    new Date(tweetResult.legacy.created_at).getTime() / 1000,\n                userId: tweetResult.legacy.user_id_str,\n                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n                hashtags: [],\n                mentions: [],\n                photos: [],\n                thread: [],\n                urls: [],\n                videos: [],\n            };\n            sentTweets.push(finalTweet);\n            previousTweetId = finalTweet.id;\n        } else {\n            console.error(\"Error sending chunk\", chunk, \"repsonse:\", body);\n        }\n\n        // Wait a bit between tweets to avoid rate limiting issues\n        await wait(1000, 2000);\n    }\n\n    const memories: Memory[] = sentTweets.map((tweet) => ({\n        id: stringToUuid(tweet.id + \"-\" + client.runtime.agentId),\n        agentId: client.runtime.agentId,\n        userId: client.runtime.agentId,\n        content: {\n            text: tweet.text,\n            source: \"twitter\",\n            url: tweet.permanentUrl,\n            inReplyTo: tweet.inReplyToStatusId\n                ? stringToUuid(\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\n                  )\n                : undefined,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000,\n    }));\n\n    return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\n    const tweets: string[] = [];\n    let currentTweet = \"\";\n\n    for (const paragraph of paragraphs) {\n        if (!paragraph) continue;\n\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\n            if (currentTweet) {\n                currentTweet += \"\\n\\n\" + paragraph;\n            } else {\n                currentTweet = paragraph;\n            }\n        } else {\n            if (currentTweet) {\n                tweets.push(currentTweet.trim());\n            }\n            if (paragraph.length <= maxLength) {\n                currentTweet = paragraph;\n            } else {\n                // Split long paragraph into smaller chunks\n                const chunks = splitParagraph(paragraph, maxLength);\n                tweets.push(...chunks.slice(0, -1));\n                currentTweet = chunks[chunks.length - 1];\n            }\n        }\n    }\n\n    if (currentTweet) {\n        tweets.push(currentTweet.trim());\n    }\n\n    return tweets;\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n    // eslint-disable-next-line\n    const sentences = paragraph.match(/[^\\.!\\?]+[\\.!\\?]+|[^\\.!\\?]+$/g) || [\n        paragraph,\n    ];\n    const chunks: string[] = [];\n    let currentChunk = \"\";\n\n    for (const sentence of sentences) {\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\n            if (currentChunk) {\n                currentChunk += \" \" + sentence;\n            } else {\n                currentChunk = sentence;\n            }\n        } else {\n            if (currentChunk) {\n                chunks.push(currentChunk.trim());\n            }\n            if (sentence.length <= maxLength) {\n                currentChunk = sentence;\n            } else {\n                // Split long sentence into smaller pieces\n                const words = sentence.split(\" \");\n                currentChunk = \"\";\n                for (const word of words) {\n                    if (\n                        (currentChunk + \" \" + word).trim().length <= maxLength\n                    ) {\n                        if (currentChunk) {\n                            currentChunk += \" \" + word;\n                        } else {\n                            currentChunk = word;\n                        }\n                    } else {\n                        if (currentChunk) {\n                            chunks.push(currentChunk.trim());\n                        }\n                        currentChunk = word;\n                    }\n                }\n            }\n        }\n    }\n\n    if (currentChunk) {\n        chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n}\n","import { Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateText,\n    getEmbeddingZeroVector,\n    IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    parseBooleanFromText,\n} from \"@ai16z/eliza\";\nimport { elizaLogger } from \"@ai16z/eliza\";\nimport { ClientBase } from \"./base.ts\";\nimport { postActionResponseFooter } from \"@ai16z/eliza\";\nimport { generateTweetActions } from \"@ai16z/eliza\";\nimport { IImageDescriptionService, ServiceType } from \"@ai16z/eliza\";\nimport { buildConversationThread } from \"./utils.ts\";\nimport { twitterMessageHandlerTemplate } from \"./interactions.ts\";\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n# Task: Generate a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.\nWrite a post that is {{adjective}} about {{topic}}, from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}. No emojis. Use \\\\n\\\\n (double spaces) between statements if there are multiple statements in your response.`;\n\nexport const twitterActionTemplate =\n    `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- Highly selective engagement\n- Direct mentions are priority\n- Skip: low-effort content, off-topic, repetitive\n\nActions (respond only with tags):\n[LIKE] - Resonates with interests (9.5/10)\n[RETWEET] - Perfect character alignment (9/10)\n[QUOTE] - Can add unique value (8/10)\n[REPLY] - Memetic opportunity (9/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only.` + postActionResponseFooter;\n\nconst MAX_TWEET_LENGTH = 240;\n\n/**\n * Truncate text to fit within the Twitter character limit, ensuring it ends at a complete sentence.\n */\nfunction truncateToCompleteSentence(\n    text: string,\n    maxTweetLength: number\n): string {\n    if (text.length <= maxTweetLength) {\n        return text;\n    }\n\n    // Attempt to truncate at the last period within the limit\n    const truncatedAtPeriod = text.slice(\n        0,\n        text.lastIndexOf(\".\", maxTweetLength) + 1\n    );\n    if (truncatedAtPeriod.trim().length > 0) {\n        return truncatedAtPeriod.trim();\n    }\n\n    // If no period is found, truncate to the nearest whitespace\n    const truncatedAtSpace = text.slice(\n        0,\n        text.lastIndexOf(\" \", maxTweetLength)\n    );\n    if (truncatedAtSpace.trim().length > 0) {\n        return truncatedAtSpace.trim() + \"...\";\n    }\n\n    // Fallback: Hard truncate and add ellipsis\n    return text.slice(0, maxTweetLength - 3).trim() + \"...\";\n}\n\nexport class TwitterPostClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private isProcessing: boolean = false;\n    private lastProcessTime: number = 0;\n    private stopProcessingActions: boolean = false;\n\n    async start(postImmediately: boolean = false) {\n        if (!this.client.profile) {\n            await this.client.init();\n        }\n\n        const generateNewTweetLoop = async () => {\n            const lastPost = await this.runtime.cacheManager.get<{\n                timestamp: number;\n            }>(\"twitter/\" + this.twitterUsername + \"/lastPost\");\n\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\n            const minMinutes =\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MIN\")) || 90;\n            const maxMinutes =\n                parseInt(this.runtime.getSetting(\"POST_INTERVAL_MAX\")) || 180;\n            const randomMinutes =\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\n                minMinutes;\n            const delay = randomMinutes * 60 * 1000;\n\n            if (Date.now() > lastPostTimestamp + delay) {\n                await this.generateNewTweet();\n            }\n\n            setTimeout(() => {\n                generateNewTweetLoop(); // Set up next iteration\n            }, delay);\n\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\n        };\n\n        const processActionsLoop = async () => {\n            const actionInterval =\n                parseInt(this.runtime.getSetting(\"ACTION_INTERVAL\")) || 300000; // Default to 5 minutes\n\n            while (!this.stopProcessingActions) {\n                try {\n                    const results = await this.processTweetActions();\n                    if (results) {\n                        elizaLogger.log(`Processed ${results.length} tweets`);\n                        elizaLogger.log(\n                            `Next action processing scheduled in ${actionInterval / 1000} seconds`\n                        );\n                        // Wait for the full interval before next processing\n                        await new Promise((resolve) =>\n                            setTimeout(resolve, actionInterval)\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error in action processing loop:\",\n                        error\n                    );\n                    // Add exponential backoff on error\n                    await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\n                }\n            }\n        };\n\n        if (\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != null &&\n            this.runtime.getSetting(\"POST_IMMEDIATELY\") != \"\"\n        ) {\n            postImmediately = parseBooleanFromText(\n                this.runtime.getSetting(\"POST_IMMEDIATELY\")\n            );\n        }\n\n        if (postImmediately) {\n            await this.generateNewTweet();\n        }\n        generateNewTweetLoop();\n\n        // Add check for ENABLE_ACTION_PROCESSING before starting the loop\n        const enableActionProcessing = this.runtime.getSetting(\"ENABLE_ACTION_PROCESSING\") ?? false;\n\n        if (enableActionProcessing) {\n            processActionsLoop().catch((error) => {\n                elizaLogger.error(\n                    \"Fatal error in process actions loop:\",\n                    error\n                );\n            });\n        } else {\n            elizaLogger.log(\"Action processing loop disabled by configuration\");\n        }\n        generateNewTweetLoop();\n    }\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = runtime.getSetting(\"TWITTER_USERNAME\");\n    }\n\n    private async generateNewTweet(taskPrompt: string = \"\") {\n        elizaLogger.log(\"Generating new tweet\");\n\n        try {\n            const roomId = stringToUuid(\n                \"twitter_generate_room-\" + this.client.profile.username\n            );\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.client.profile.username,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const topics = taskPrompt || this.runtime.character.topics.join(\", \");\n\n            const state = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: roomId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: topics,\n                        action: \"TWEET\",\n                    },\n                },\n                {\n                    twitterUserName: this.client.profile.username,\n                }\n            );\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterPostTemplate ||\n                    twitterPostTemplate,\n            });\n\n            console.log(\"twitter context:\\n\" + context);\n\n            elizaLogger.debug(\"generate post prompt:\\n\" + context);\n\n            const newTweetContent = await generateText({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            // First attempt to clean content\n            let cleanedContent = \"\";\n\n            // Try parsing as JSON first\n            try {\n                const parsedResponse = JSON.parse(newTweetContent);\n                if (parsedResponse.text) {\n                    cleanedContent = parsedResponse.text;\n                } else if (typeof parsedResponse === \"string\") {\n                    cleanedContent = parsedResponse;\n                }\n            } catch (error) {\n                error.linted = true; // make linter happy since catch needs a variable\n                // If not JSON, clean the raw content\n                cleanedContent = newTweetContent\n                    .replace(/^\\s*{?\\s*\"text\":\\s*\"|\"\\s*}?\\s*$/g, \"\") // Remove JSON-like wrapper\n                    .replace(/^['\"](.*)['\"]$/g, \"$1\") // Remove quotes\n                    .replace(/\\\\\"/g, '\"') // Unescape quotes\n                    .replace(/\\\\n/g, \"\\n\") // Unescape newlines\n                    .trim();\n            }\n\n            if (!cleanedContent) {\n                elizaLogger.error(\n                    \"Failed to extract valid content from response:\",\n                    {\n                        rawResponse: newTweetContent,\n                        attempted: \"JSON parsing\",\n                    }\n                );\n                return;\n            }\n\n            // Use the helper function to truncate to complete sentence\n            const content = truncateToCompleteSentence(\n                cleanedContent,\n                MAX_TWEET_LENGTH\n            );\n\n            const removeQuotes = (str: string) =>\n                str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n            const fixNewLines = (str: string) => str.replaceAll(/\\\\n/g, \"\\n\");\n\n            // Final cleaning\n            cleanedContent = removeQuotes(fixNewLines(content));\n\n            if (this.runtime.getSetting(\"TWITTER_DRY_RUN\") === \"true\") {\n                elizaLogger.info(\n                    `Dry run: would have posted tweet: ${cleanedContent}`\n                );\n                return;\n            }\n\n            try {\n                elizaLogger.log(`Posting new tweet:\\n ${cleanedContent}`);\n\n                const result = await this.client.requestQueue.add(\n                    async () =>\n                        await this.client.twitterClient.sendTweet(\n                            cleanedContent\n                        )\n                );\n                const body = await result.json();\n                if (!body?.data?.create_tweet?.tweet_results?.result) {\n                    console.error(\"Error sending tweet; Bad response:\", body);\n                    return;\n                }\n                const tweetResult = body.data.create_tweet.tweet_results.result;\n\n                const tweet = {\n                    id: tweetResult.rest_id,\n                    name: this.client.profile.screenName,\n                    username: this.client.profile.username,\n                    text: tweetResult.legacy.full_text,\n                    conversationId: tweetResult.legacy.conversation_id_str,\n                    createdAt: tweetResult.legacy.created_at,\n                    timestamp: new Date(\n                        tweetResult.legacy.created_at\n                    ).getTime(),\n                    userId: this.client.profile.id,\n                    inReplyToStatusId:\n                        tweetResult.legacy.in_reply_to_status_id_str,\n                    permanentUrl: `https://twitter.com/${this.twitterUsername}/status/${tweetResult.rest_id}`,\n                    hashtags: [],\n                    mentions: [],\n                    photos: [],\n                    thread: [],\n                    urls: [],\n                    videos: [],\n                } as Tweet;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/${this.client.profile.username}/lastPost`,\n                    {\n                        id: tweet.id,\n                        timestamp: Date.now(),\n                    }\n                );\n\n                await this.client.cacheTweet(tweet);\n\n                elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n                await this.runtime.ensureRoomExists(roomId);\n                await this.runtime.ensureParticipantInRoom(\n                    this.runtime.agentId,\n                    roomId\n                );\n\n                await this.runtime.messageManager.createMemory({\n                    id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                    userId: this.runtime.agentId,\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: newTweetContent.trim(),\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                    },\n                    roomId,\n                    embedding: getEmbeddingZeroVector(),\n                    createdAt: tweet.timestamp,\n                });\n            } catch (error) {\n                elizaLogger.error(\"Error sending tweet:\", error);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error generating new tweet:\", error);\n        }\n    }\n\n    private async generateTweetContent(\n        tweetState: any,\n        options?: {\n            template?: string;\n            context?: string;\n        }\n    ): Promise<string> {\n        const context = composeContext({\n            state: tweetState,\n            template:\n                options?.template ||\n                this.runtime.character.templates?.twitterPostTemplate ||\n                twitterPostTemplate,\n        });\n\n        const response = await generateText({\n            runtime: this.runtime,\n            context: options?.context || context,\n            modelClass: ModelClass.SMALL,\n        });\n        console.log(\"generate tweet content response:\\n\" + response);\n\n        // First clean up any markdown and newlines\n        const cleanedResponse = response\n            .replace(/```json\\s*/g, \"\") // Remove ```json\n            .replace(/```\\s*/g, \"\") // Remove any remaining ```\n            .replaceAll(/\\\\n/g, \"\\n\")\n            .trim();\n\n        // Try to parse as JSON first\n        try {\n            const jsonResponse = JSON.parse(cleanedResponse);\n            if (jsonResponse.text) {\n                return this.trimTweetLength(jsonResponse.text);\n            }\n            if (typeof jsonResponse === \"object\") {\n                const possibleContent =\n                    jsonResponse.content ||\n                    jsonResponse.message ||\n                    jsonResponse.response;\n                if (possibleContent) {\n                    return this.trimTweetLength(possibleContent);\n                }\n            }\n        } catch (error) {\n            error.linted = true; // make linter happy since catch needs a variable\n\n            // If JSON parsing fails, treat as plain text\n            elizaLogger.debug(\"Response is not JSON, treating as plain text\");\n        }\n\n        // If not JSON or no valid content found, clean the raw text\n        return this.trimTweetLength(cleanedResponse);\n    }\n\n    // Helper method to ensure tweet length compliance\n    private trimTweetLength(text: string, maxLength: number = 280): string {\n        if (text.length <= maxLength) return text;\n\n        // Try to cut at last sentence\n        const lastSentence = text.slice(0, maxLength).lastIndexOf(\".\");\n        if (lastSentence > 0) {\n            return text.slice(0, lastSentence + 1).trim();\n        }\n\n        // Fallback to word boundary\n        return (\n            text.slice(0, text.lastIndexOf(\" \", maxLength - 3)).trim() + \"...\"\n        );\n    }\n\n    private async processTweetActions() {\n        if (this.isProcessing) {\n            elizaLogger.log(\"Already processing tweet actions, skipping\");\n            return null;\n        }\n\n        try {\n            this.isProcessing = true;\n            this.lastProcessTime = Date.now();\n\n            elizaLogger.log(\"Processing tweet actions\");\n\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.twitterUsername,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const homeTimeline = await this.client.fetchTimelineForActions(15);\n            const results = [];\n\n            for (const tweet of homeTimeline) {\n                try {\n                    // Skip if we've already processed this tweet\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n                    if (memory) {\n                        elizaLogger.log(\n                            `Already processed tweet ID: ${tweet.id}`\n                        );\n                        continue;\n                    }\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const tweetState = await this.runtime.composeState(\n                        {\n                            userId: this.runtime.agentId,\n                            roomId,\n                            agentId: this.runtime.agentId,\n                            content: { text: \"\", action: \"\" },\n                        },\n                        {\n                            twitterUserName: this.twitterUsername,\n                            currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n                        }\n                    );\n\n                    const actionContext = composeContext({\n                        state: tweetState,\n                        template:\n                            this.runtime.character.templates\n                                ?.twitterActionTemplate ||\n                            twitterActionTemplate,\n                    });\n\n                    const actionResponse = await generateTweetActions({\n                        runtime: this.runtime,\n                        context: actionContext,\n                        modelClass: ModelClass.SMALL,\n                    });\n\n                    if (!actionResponse) {\n                        elizaLogger.log(\n                            `No valid actions generated for tweet ${tweet.id}`\n                        );\n                        continue;\n                    }\n\n                    const executedActions: string[] = [];\n\n                    // Execute actions\n                    if (actionResponse.like) {\n                        try {\n                            await this.client.twitterClient.likeTweet(tweet.id);\n                            executedActions.push(\"like\");\n                            elizaLogger.log(`Liked tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error liking tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n\n                    if (actionResponse.retweet) {\n                        try {\n                            await this.client.twitterClient.retweet(tweet.id);\n                            executedActions.push(\"retweet\");\n                            elizaLogger.log(`Retweeted tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error retweeting tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n\n                    if (actionResponse.quote) {\n                        try {\n                            // Build conversation thread for context\n                            const thread = await buildConversationThread(\n                                tweet,\n                                this.client\n                            );\n                            const formattedConversation = thread\n                                .map(\n                                    (t) =>\n                                        `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\n                                )\n                                .join(\"\\n\\n\");\n\n                            // Generate image descriptions if present\n                            const imageDescriptions = [];\n                            if (tweet.photos?.length > 0) {\n                                elizaLogger.log(\n                                    \"Processing images in tweet for context\"\n                                );\n                                for (const photo of tweet.photos) {\n                                    const description = await this.runtime\n                                        .getService<IImageDescriptionService>(\n                                            ServiceType.IMAGE_DESCRIPTION\n                                        )\n                                        .describeImage(photo.url);\n                                    imageDescriptions.push(description);\n                                }\n                            }\n\n                            // Handle quoted tweet if present\n                            let quotedContent = \"\";\n                            if (tweet.quotedStatusId) {\n                                try {\n                                    const quotedTweet =\n                                        await this.client.twitterClient.getTweet(\n                                            tweet.quotedStatusId\n                                        );\n                                    if (quotedTweet) {\n                                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                                    }\n                                } catch (error) {\n                                    elizaLogger.error(\n                                        \"Error fetching quoted tweet:\",\n                                        error\n                                    );\n                                }\n                            }\n\n                            // Compose rich state with all context\n                            const enrichedState =\n                                await this.runtime.composeState(\n                                    {\n                                        userId: this.runtime.agentId,\n                                        roomId: stringToUuid(\n                                            tweet.conversationId +\n                                                \"-\" +\n                                                this.runtime.agentId\n                                        ),\n                                        agentId: this.runtime.agentId,\n                                        content: {\n                                            text: tweet.text,\n                                            action: \"QUOTE\",\n                                        },\n                                    },\n                                    {\n                                        twitterUserName: this.twitterUsername,\n                                        currentPost: `From @${tweet.username}: ${tweet.text}`,\n                                        formattedConversation,\n                                        imageContext:\n                                            imageDescriptions.length > 0\n                                                ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\n                                                : \"\",\n                                        quotedContent,\n                                    }\n                                );\n\n                            const quoteContent =\n                                await this.generateTweetContent(enrichedState, {\n                                    template:\n                                        this.runtime.character.templates\n                                            ?.twitterMessageHandlerTemplate ||\n                                        twitterMessageHandlerTemplate,\n                                });\n\n                            if (!quoteContent) {\n                                elizaLogger.error(\n                                    \"Failed to generate valid quote tweet content\"\n                                );\n                                return;\n                            }\n\n                            elizaLogger.log(\n                                \"Generated quote tweet content:\",\n                                quoteContent\n                            );\n\n                            // Send the tweet through request queue\n                            const result = await this.client.requestQueue.add(\n                                async () =>\n                                    await this.client.twitterClient.sendQuoteTweet(\n                                        quoteContent,\n                                        tweet.id\n                                    )\n                            );\n\n                            const body = await result.json();\n\n                            if (\n                                body?.data?.create_tweet?.tweet_results?.result\n                            ) {\n                                elizaLogger.log(\n                                    \"Successfully posted quote tweet\"\n                                );\n                                executedActions.push(\"quote\");\n\n                                // Cache generation context for debugging\n                                await this.runtime.cacheManager.set(\n                                    `twitter/quote_generation_${tweet.id}.txt`,\n                                    `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent}`\n                                );\n                            } else {\n                                elizaLogger.error(\n                                    \"Quote tweet creation failed:\",\n                                    body\n                                );\n                            }\n                        } catch (error) {\n                            elizaLogger.error(\n                                \"Error in quote tweet generation:\",\n                                error\n                            );\n                        }\n                    }\n\n                    if (actionResponse.reply) {\n                        try {\n                            await this.handleTextOnlyReply(\n                                tweet,\n                                tweetState,\n                                executedActions\n                            );\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error replying to tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n\n                    // Add these checks before creating memory\n                    await this.runtime.ensureRoomExists(roomId);\n                    await this.runtime.ensureUserExists(\n                        stringToUuid(tweet.userId),\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n                    await this.runtime.ensureParticipantInRoom(\n                        this.runtime.agentId,\n                        roomId\n                    );\n\n                    // Then create the memory\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId: stringToUuid(tweet.userId),\n                        content: {\n                            text: tweet.text,\n                            url: tweet.permanentUrl,\n                            source: \"twitter\",\n                            action: executedActions.join(\",\"),\n                        },\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    results.push({\n                        tweetId: tweet.id,\n                        parsedActions: actionResponse,\n                        executedActions,\n                    });\n                } catch (error) {\n                    elizaLogger.error(\n                        `Error processing tweet ${tweet.id}:`,\n                        error\n                    );\n                    continue;\n                }\n            }\n\n            return results; // Return results array to indicate completion\n        } catch (error) {\n            elizaLogger.error(\"Error in processTweetActions:\", error);\n            throw error;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    private async handleTextOnlyReply(\n        tweet: Tweet,\n        tweetState: any,\n        executedActions: string[]\n    ) {\n        try {\n            // Build conversation thread for context\n            const thread = await buildConversationThread(tweet, this.client);\n            const formattedConversation = thread\n                .map(\n                    (t) =>\n                        `@${t.username} (${new Date(t.timestamp * 1000).toLocaleString()}): ${t.text}`\n                )\n                .join(\"\\n\\n\");\n\n            // Generate image descriptions if present\n            const imageDescriptions = [];\n            if (tweet.photos?.length > 0) {\n                elizaLogger.log(\"Processing images in tweet for context\");\n                for (const photo of tweet.photos) {\n                    const description = await this.runtime\n                        .getService<IImageDescriptionService>(\n                            ServiceType.IMAGE_DESCRIPTION\n                        )\n                        .describeImage(photo.url);\n                    imageDescriptions.push(description);\n                }\n            }\n\n            // Handle quoted tweet if present\n            let quotedContent = \"\";\n            if (tweet.quotedStatusId) {\n                try {\n                    const quotedTweet =\n                        await this.client.twitterClient.getTweet(\n                            tweet.quotedStatusId\n                        );\n                    if (quotedTweet) {\n                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                    }\n                } catch (error) {\n                    elizaLogger.error(\"Error fetching quoted tweet:\", error);\n                }\n            }\n\n            // Compose rich state with all context\n            const enrichedState = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: { text: tweet.text, action: \"\" },\n                },\n                {\n                    twitterUserName: this.twitterUsername,\n                    currentPost: `From @${tweet.username}: ${tweet.text}`,\n                    formattedConversation,\n                    imageContext:\n                        imageDescriptions.length > 0\n                            ? `\\nImages in Tweet:\\n${imageDescriptions.map((desc, i) => `Image ${i + 1}: ${desc}`).join(\"\\n\")}`\n                            : \"\",\n                    quotedContent,\n                }\n            );\n\n            // Generate and clean the reply content\n            const replyText = await this.generateTweetContent(enrichedState, {\n                template:\n                    this.runtime.character.templates\n                        ?.twitterMessageHandlerTemplate ||\n                    twitterMessageHandlerTemplate,\n            });\n\n            if (!replyText) {\n                elizaLogger.error(\"Failed to generate valid reply content\");\n                return;\n            }\n\n            elizaLogger.debug(\"Final reply text to be sent:\", replyText);\n\n            // Send the tweet through request queue\n            const result = await this.client.requestQueue.add(\n                async () =>\n                    await this.client.twitterClient.sendTweet(\n                        replyText,\n                        tweet.id\n                    )\n            );\n\n            const body = await result.json();\n\n            if (body?.data?.create_tweet?.tweet_results?.result) {\n                elizaLogger.log(\"Successfully posted reply tweet\");\n                executedActions.push(\"reply\");\n\n                // Cache generation context for debugging\n                await this.runtime.cacheManager.set(\n                    `twitter/reply_generation_${tweet.id}.txt`,\n                    `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyText}`\n                );\n            } else {\n                elizaLogger.error(\"Tweet reply creation failed:\", body);\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error in handleTextOnlyReply:\", error);\n        }\n    }\n\n    async stop() {\n        this.stopProcessingActions = true;\n    }\n}\n"],"mappings":"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","names":["elizaLogger","cookies","existingMemories","existingMemoryIds","tweetsToSave","profile","SearchMode","stringToUuid","elizaLogger","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","elizaLogger","stringToUuid","getEmbeddingZeroVector","elizaLogger","SearchMode","stringToUuid","tweet","message","response","getEmbeddingZeroVector","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","elizaLogger","stringToUuid","composeContext","ModelClass","getEmbeddingZeroVector","elizaLogger"]}